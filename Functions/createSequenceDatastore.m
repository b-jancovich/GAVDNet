function varargout = createSequenceDatastore(sequencesPath, varargin)
% CREATESEQUENCEDATASTORE Creates a datastore that reads sequence and mask
% data files generated by constructNoisySequences
%
% Inputs:
% sequencesPath - path to the folder containing audiosequence_and_mask_*.mat files
% split - (optional) 1x2 array with proportions for train and validation [trainProp, valProp]
%
% Outputs:
% If no split is provided:
%   ds - datastore object that returns [audioSequence, mask] when read
% If split is provided:
%   trainDS - datastore with training data (e.g., 85%)
%   valDS - datastore with validation data (e.g., 15%)
%
% Usage:
% ds = createSequenceDatastore('path/to/sequences');
% [audioSeq, mask] = read(ds);
% 
% OR
%
% [trainDS, valDS] = createSequenceDatastore('path/to/sequences', [0.85, 0.15]);
%
% Ben Jancovich, 2024
% Centre for Marine Science and Innovation
% School of Biological, Earth and Environmental Sciences
% University of New South Wales, Sydney, Australia
%
% Check if sequencesPath exists
if ~exist(sequencesPath, 'dir')
 error('Directory does not exist: %s', sequencesPath);
end

% Find all sequence files
files = dir(fullfile(sequencesPath, 'audiosequence_and_mask_*.mat'));
if isempty(files)
 error('No audiosequence_and_mask_*.mat files found in %s', sequencesPath);
end

% Get full file paths
filePaths = fullfile({files.folder}, {files.name});

% Check if we need to split the data
if nargin > 1 && length(varargin) >= 1
    split = varargin{1};
    
    % Validate split
    if numel(split) ~= 2 || sum(split) ~= 1 || any(split <= 0)
        error('Split must be a 1x2 array with positive values that sum to 1');
    end
    
    % Shuffle the files randomly
    numFiles = length(filePaths);
    indices = randperm(numFiles);
    shuffledFiles = filePaths(indices);
    
    % Calculate number of files for training
    numTrainFiles = round(numFiles * split(1));
    
    % Split the file list
    trainFiles = shuffledFiles(1:numTrainFiles);
    valFiles = shuffledFiles(numTrainFiles+1:end);
    
    % Create datastores for each set with the correct read function
    trainDS = fileDatastore(trainFiles, 'ReadFcn', @readAndReturnAsStruct, 'FileExtensions', '.mat');
    valDS = fileDatastore(valFiles, 'ReadFcn', @readAndReturnAsStruct, 'FileExtensions', '.mat');
    
    fprintf('Created training datastore with %d sequence files.\n', length(trainDS.Files));
    fprintf('Created validation datastore with %d sequence files.\n', length(valDS.Files));
    
    % Set output arguments
    varargout{1} = trainDS;
    varargout{2} = valDS;
else
    % Create a single datastore with all files
    ds = fileDatastore(filePaths, 'ReadFcn', @readAndReturnAsStruct, 'FileExtensions', '.mat');
    fprintf('Created datastore with %d sequence files.\n', length(ds.Files));
    
    % Set output argument
    varargout{1} = ds;
end
end

function data = readSequenceFile(filename)
% Helper function to read a sequence file
try
    % Load the MAT file
    matData = load(filename);
    % Extract the sequence and mask
    if isfield(matData, 'audioSequence') && isfield(matData, 'mask')
        % Return as a 1x2 cell array
        data = {matData.audioSequence, matData.mask};
    else
        error('File does not contain required fields: audioSequence and mask');
    end
catch e
    warning('Error reading file %s: %s', filename, e.message);
    % Return empty data
    data = {[], []};
end
end

function data = readAndReturnAsStruct(filename)
% Helper function that returns data in a struct format for proper unpacking
try
    % Load the MAT file
    matData = load(filename);
    % Extract the sequence and mask
    if isfield(matData, 'audioSequence') && isfield(matData, 'mask')
        % Return as a struct with fields
        data.audioSequence = matData.audioSequence;
        data.mask = matData.mask;
    else
        error('File does not contain required fields: audioSequence and mask');
    end
catch e
    warning('Error reading file %s: %s', filename, e.message);
    % Return empty data
    data.audioSequence = [];
    data.mask = [];
end
end